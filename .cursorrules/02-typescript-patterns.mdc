---
globs: *.ts,*.tsx
description: TypeScript patterns, best practices, and coding standards
---

# TypeScript Coding Standards

## üéØ Type Safety (MANDATORY)

### ‚úÖ ALWAYS use explicit types

```typescript
// ‚úÖ CORRECT - Explicit return types
async getUserById(id: string): Promise<UserInfo> {
    return await this.userRepository.findOneById(id);
}

// ‚ùå WRONG - No return type
async getUserById(id: string) {
    return await this.userRepository.findOneById(id);
}
```

### ‚úÖ ALWAYS use strict null checks

```typescript
// ‚úÖ CORRECT - Handle null explicitly
const user = await this.userRepository.findOneById(id);
if (!user) {
    throw new DomainException(...);
}
return user;

// ‚ùå WRONG - Not handling potential null
const user = await this.userRepository.findOneById(id);
return user; // Could be null!
```

### ‚ùå NEVER use `any` type

```typescript
// ‚ùå FORBIDDEN
async processData(data: any): Promise<any> {}

// ‚úÖ CORRECT - Use proper types
async processUserData(data: CreateUserDto): Promise<UserInfo> {}

// ‚úÖ CORRECT - Use unknown for truly unknown types
async handleError(error: unknown): Promise<void> {
    if (error instanceof Error) {
        // Handle error
    }
}
```

## üèóÔ∏è Dependency Injection (MUST FOLLOW)

### Constructor Injection Pattern

```typescript
@Injectable()
export class UserService {
    constructor(
        private readonly userReader: UserReader,
        private readonly userWriter: UserWriter,
        private readonly friendReader: FriendReader,
    ) {}

    // MUST use readonly for injected dependencies
    // MUST use private for dependencies
}
```

### ‚ùå FORBIDDEN: Property Injection

```typescript
// ‚ùå WRONG
@Injectable()
export class UserService {
    @Inject(UserReader)
    userReader: UserReader; // NEVER use property injection
}
```

### Repository Injection with Symbol

```typescript
// ‚úÖ CORRECT - Use Symbol for interface injection
@Injectable()
export class UserReader {
    constructor(
        @Inject(UserRepository)
        private readonly userRepository: UserRepository,
    ) {}
}
```

## üé® Class Structure (MANDATORY ORDER)

```typescript
@Injectable()
export class UserService {
    // 1. Static properties
    private static readonly DEFAULT_LIMIT = 10;

    // 2. Instance properties
    private readonly maxRetryCount = 3;

    // 3. Constructor
    constructor(
        private readonly userReader: UserReader,
        private readonly userWriter: UserWriter,
    ) {}

    // 4. Public methods
    async createUser(data: CreateUserDto): Promise<void> {
        // Implementation
    }

    async getUserById(id: string): Promise<UserInfo> {
        // Implementation
    }

    // 5. Private methods (at the end)
    private async validateUserData(data: CreateUserDto): Promise<void> {
        // Implementation
    }
}
```

## üîí Access Modifiers (STRICT RULES)

### ALWAYS use explicit access modifiers

```typescript
// ‚úÖ CORRECT
export class UserService {
    public async createUser(data: CreateUserDto): Promise<void> {}
    private async validateData(data: any): Promise<void> {}
}

// ‚ùå WRONG - Missing access modifiers
export class UserService {
    async createUser(data: CreateUserDto): Promise<void> {}
    validateData(data: any): Promise<void> {}
}
```

### Use `readonly` for immutable properties

```typescript
// ‚úÖ CORRECT
constructor(
    private readonly userRepository: UserRepository,
    private readonly maxRetries: number = 3,
) {}

// ‚ùå WRONG
constructor(
    private userRepository: UserRepository, // Should be readonly
) {}
```

## üé≠ Interface vs Type

### Use Interface for object shapes (PREFERRED)

```typescript
// ‚úÖ CORRECT - Use interface for objects
export interface UserInfo {
    id: string;
    email: string;
    nickname: string;
}

export interface CreateUserRequest {
    email: string;
    nickname: string;
    tag: string;
}
```

### Use Type for unions, intersections, primitives

```typescript
// ‚úÖ CORRECT - Use type for unions
export type IslandType = 'NORMAL' | 'PRIVATE' | 'DESERTED';
export type UserId = string;

// ‚úÖ CORRECT - Use type for intersections
export type UserWithFriend = UserInfo & { friendStatus: FriendStatus };
```

## üì¶ Import/Export (MANDATORY ORGANIZATION)

### Import Order (MUST FOLLOW)

```typescript
// 1. External libraries
import { Injectable, HttpStatus } from '@nestjs/common';
import { TransactionHost } from '@nestjs-cls/transactional';

// 2. Internal absolute imports (grouped by layer)
import { UserRepository } from 'src/domain/interface/user.repository';
import { UserEntity } from 'src/domain/entities/user/user.entity';
import { DomainException } from 'src/domain/exceptions/exceptions';

// 3. Relative imports (avoid if possible)
import { helperFunction } from './helper';
```

### ‚ùå NEVER use relative imports across layers

```typescript
// ‚ùå WRONG
import { UserRepository } from '../../../domain/interface/user.repository';

// ‚úÖ CORRECT
import { UserRepository } from 'src/domain/interface/user.repository';
```

### Named Exports (REQUIRED)

```typescript
// ‚úÖ CORRECT - Named exports
export class UserService {}
export interface UserInfo {}
export const MAX_RETRY = 3;

// ‚ùå WRONG - Default exports (except for modules)
export default class UserService {}
```

## üîÑ Async/Await (BEST PRACTICES)

### ALWAYS use async/await over Promises

```typescript
// ‚úÖ CORRECT
async getUserProfile(id: string): Promise<UserInfo> {
    const user = await this.userRepository.findOneById(id);
    if (!user) {
        throw new DomainException(...);
    }
    return user;
}

// ‚ùå WRONG - Using .then/.catch
getUserProfile(id: string): Promise<UserInfo> {
    return this.userRepository.findOneById(id)
        .then(user => {
            if (!user) throw new DomainException(...);
            return user;
        });
}
```

### Parallel Operations

```typescript
// ‚úÖ CORRECT - Execute in parallel when possible
async getUserWithFriends(userId: string): Promise<UserWithFriends> {
    const [user, friends] = await Promise.all([
        this.userReader.getUserById(userId),
        this.friendReader.getFriendsList(userId),
    ]);

    return { ...user, friends };
}

// ‚ùå WRONG - Sequential when parallel is possible
async getUserWithFriends(userId: string): Promise<UserWithFriends> {
    const user = await this.userReader.getUserById(userId);
    const friends = await this.friendReader.getFriendsList(userId);
    return { ...user, friends };
}
```

## üõ°Ô∏è Error Handling (CRITICAL)

### Domain Layer - Use DomainException

```typescript
// ‚úÖ CORRECT
async getUserById(id: string): Promise<UserInfo> {
    const user = await this.userRepository.findOneById(id);

    if (!user) {
        throw new DomainException(
            DomainExceptionType.USER_NOT_FOUND,
            HttpStatus.NOT_FOUND,
            USER_NOT_FOUND_MESSAGE,
        );
    }

    return user;
}
```

### Try-Catch ONLY for expected business errors

```typescript
// ‚úÖ CORRECT - Specific error handling
async changeTag(userId: string, tag: string): Promise<void> {
    try {
        const existingUser = await this.userReader.readOneByTag(tag);

        if (existingUser) {
            throw new DomainException(
                DomainExceptionType.TAG_CONFLICT,
                HttpStatus.CONFLICT,
                TAG_CONFLICT_MESSAGE,
            );
        }
    } catch (error: unknown) {
        if (error instanceof DomainException &&
            error.errorType === DomainExceptionType.USER_NOT_FOUND) {
            // Tag is available, proceed with update
            return await this.userWriter.updateTag(userId, tag);
        }
        throw error; // Re-throw unexpected errors
    }
}

// ‚ùå WRONG - Catching everything
try {
    await someOperation();
} catch (error) {
    console.log(error); // NEVER do this
}
```

## üéØ Type Guards

### Use type guards for unknown types

```typescript
// ‚úÖ CORRECT
function isUserInfo(obj: unknown): obj is UserInfo {
    return (
        typeof obj === 'object' &&
        obj !== null &&
        'id' in obj &&
        'email' in obj
    );
}

async handleData(data: unknown): Promise<void> {
    if (!isUserInfo(data)) {
        throw new Error('Invalid user data');
    }

    // data is now typed as UserInfo
    await this.processUser(data);
}
```

## üìù Decorators (NestJS Specific)

### Controller Decorators - Proper Order

```typescript
@ApiOperation({ summary: 'Get user profile' })
@ApiResponse({ status: 200, type: UserDetailResponse })
@ApiResponse({ status: 404, description: 'User not found' })
@Get(':id')
async getUser(@Param('id') id: string): Promise<UserDetailResponse> {
    // Implementation
}
```

### Validation Decorators

```typescript
// ‚úÖ CORRECT
export class CreateUserRequest {
    @ApiProperty({ example: 'user@example.com' })
    @IsEmail()
    @IsNotEmpty()
    readonly email: string;

    @ApiProperty({ example: 'username' })
    @Length(2, 20)
    @IsString()
    @IsNotEmpty()
    readonly nickname: string;
}
```

## üî¢ Enums vs Union Types

### Use Enum for values that map to numbers or need iteration

```typescript
// ‚úÖ CORRECT - Enum for database values
export enum IslandTypeEnum {
    NORMAL = 0,
    PRIVATE = 1,
    DESERTED = 2,
}
```

### Use Union Types for simple string constants

```typescript
// ‚úÖ CORRECT - Union type for simple strings
export type FriendStatus = 'PENDING' | 'ACCEPTED' | 'REJECTED';
export type SearchVariant = 'NICKNAME' | 'TAG';
```

## üö´ FORBIDDEN Patterns

### ‚ùå NEVER mutate parameters

```typescript
// ‚ùå WRONG
async updateUser(user: UserInfo): Promise<void> {
    user.nickname = 'new name'; // Mutating parameter
    await this.save(user);
}

// ‚úÖ CORRECT
async updateUser(userId: string, nickname: string): Promise<void> {
    await this.userRepository.update(userId, { nickname });
}
```

### ‚ùå NEVER use non-null assertion operator

```typescript
// ‚ùå WRONG
const user = await this.userRepository.findOneById(id);
return user!; // Dangerous!

// ‚úÖ CORRECT
const user = await this.userRepository.findOneById(id);
if (!user) {
    throw new DomainException(...);
}
return user;
```

### ‚ùå NEVER use `as` casting without validation

```typescript
// ‚ùå WRONG
const user = data as UserInfo; // No validation

// ‚úÖ CORRECT
if (!isUserInfo(data)) {
    throw new Error('Invalid data');
}
const user = data; // Type guard provides type safety
```

## üìã Code Style

### Use semicolons (MANDATORY)

```typescript
// ‚úÖ CORRECT
const userId = '123';
await this.userService.createUser(data);

// ‚ùå WRONG
const userId = '123';
await this.userService.createUser(data);
```

### Use double quotes for strings

```typescript
// ‚úÖ CORRECT
const message = 'Hello world';
const sql = 'SELECT * FROM users';

// ‚ùå WRONG
const message = 'Hello world';
```

### Spacing around operators

```typescript
// ‚úÖ CORRECT
const result = a + b + c;
const isValid = count > 0 && count < 100;

// ‚ùå WRONG
const result = a + b + c;
const isValid = count > 0 && count < 100;
```

## üéØ Summary - Critical Rules

1. ‚úÖ **ALWAYS** use explicit types and return types
2. ‚úÖ **ALWAYS** handle null/undefined explicitly
3. ‚úÖ **ALWAYS** use readonly for injected dependencies
4. ‚úÖ **ALWAYS** use DomainException in domain layer
5. ‚úÖ **ALWAYS** use async/await over promises

6. ‚ùå **NEVER** use `any` type
7. ‚ùå **NEVER** use non-null assertion (`!`)
8. ‚ùå **NEVER** use default exports
9. ‚ùå **NEVER** mutate parameters
10. ‚ùå **NEVER** ignore TypeScript errors
